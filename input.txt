
暗号論的擬似乱数生成器とは、暗号技術での利用に適した特性を持つ擬似乱数生成器 (PRNG) である。
暗号の応用では様々な場面で乱数を必要とする。
その際に必要な乱数の性質は様々である。例えば、何らかの暗号プロトコルで Nonce を生成する際に求められるのは一意性だけである。一方、鍵の生成には高い無作為性が求められる。ワンタイムパッドには暗号論的擬似乱数も不適で、高いエントロピーを持つ真の無作為情報源が必要であり、それにより情報理論的安全性を得る。

理想的には、暗号プロトコル等に使用する乱数生成には高品質の情報源から得られるエントロピーを利用すべきである。それは、例えば量子論的な乱数生成器や予測不可能な何らかの系のプロセスである。情報理論的観点では、無作為性の程度とはエントロピーであり、ある系の入力のエントロピー以上のエントロピーは出力できないからである。しかし、実用システムでは、利用可能なエントロピー以上の乱数を必要とすることがある。無作為性を引き出すプロセスには時間が掛かるためである。そのような場合に CSPRNG を使うことがある。CSPRNG は利用可能なエントロピーをより多くのビット数に拡張する。

通常のPRNGの要求仕様は、CSPRNG でも満足される。しかし、逆は真ではない。CSPRNG の要求仕様は2つに分類される。第一に、その統計的特性がよいこと（統計的無作為性の試験に合格すること）、第二に、激しい攻撃にも耐えること（初期状態や途中の状態が攻撃者に明らかになっても破られないこと）である。

全てのCSPRNGは "next-bit test" に合格する。next-bit test とは、乱数列の最初の k ビットを与えられたとき、k+1 番目のビットの値を多項式時間で2分の1をこえる確率で予測するアルゴリズムが存在しないことを確認する試験である。アンドリュー・チーチー・ヤオは1982年、next-bit test に合格した生成器は、無作為性に関する他の多項式時間統計試験にも合格することを証明した。
全てのCSPRNGは "state compromise extensions" に耐える。その状態の一部または全部が明らかになっても（あるいは正しく推測されても）、明らかにされた状態より以前に生成された乱数列は再現できない。さらに、実行中にエントロピーの入力がある場合、その入力を知っていてもCSPRNGの将来の状態を予測できない。
例: 円周率の数列から出力を生成するCSPRNGがあり、2進数化した数列のどこからを使うのか不明であるとする。これはnext-bit testを満足するが暗号論的に安全ではない。なぜなら、アルゴリズムの状態にあたる「円周率のどの部分が現在使われているか」を攻撃者が突き止めた場合、その攻撃者は先行するビットをすべて計算できるからである。
多くのPRNGはCSPRNGとしては不適であり、上記の2つを満足しない。第一にPRNGの出力は統計的に無作為に見えるが、リバースエンジニアリングには耐性がない。従って、アルゴリズムを解析することで特別な統計的試験を設計でき、PRNG の出力が真の乱数ではないことを示すことができる。第二に状態が明らかであれば、過去の乱数列を再現でき、攻撃者が全ての過去のメッセージを読むことが可能となる。当然、将来の暗号も解読可能となる。

CSPRNGは、このような暗号解読に対抗するものとして設計される。

安全なブロック暗号は、CTRモードで動作させることでCSPRNGとして使うことができる。これは、ランダムな鍵を選んで0を暗号化し、次に1を暗号化し、さらに2を暗号化し、というように行う。カウンタを0以外の任意の値から開始することもできる。明らかに、その周期は n-ビットブロック暗号では 2n であり、鍵と平文の初期値が攻撃者に知られてしまうと、全く安全でなくなる。また、誕生日のパラドックスから2n/2の出力で真の乱数と1/2の確率で識別可能である。
暗号学的ハッシュ関数も、場合によってはCSPRNGとして利用可能である。カウンタ値のハッシュ値を次々に計算すればよい。この場合、カウンタの初期値がランダムかつ秘密でなければならない。カウンタが多倍長整数であれば、このCSPRNGはほぼ無限に乱数を生成できる。しかし、これについて安全ではないとする者もいる。
ストリーム暗号は、平文を擬似乱数列と（通常 XOR で）結合することで暗号文を生成する。カウンタを平文として暗号文を生成すれば、新たな擬似乱数列が生成され、おそらく内部の疑似乱数列より周期を長くできる。この生成法は、内部で生成する擬似乱数列がCSPRNGであるときだけ安全であるが、一般にそうでないことが多い（RC4参照）。

暗号学的ハッシュ関数は、ハッシュ関数のうち、暗号など情報セキュリティの用途に適する暗号数理的性質をもつもの。任意の長さの入力を（通常は）固定長の出力に変換する。

「メッセージダイジェスト」は、暗号学的ハッシュ関数の多数ある応用のひとつであり、メールなどの「メッセージ」のビット列から暗号学的ハッシュ関数によって得たハッシュ値を、そのメッセージの内容を保証する「ダイジェスト」として利用するものである。

暗号学的ハッシュ関数は、一般的なハッシュ関数に望まれる性質や、決定的であることの他、次のような暗号学的な特性をもたなければならない。

ハッシュ値から、そのようなハッシュ値となるメッセージを得ることが（事実上）不可能であること（原像計算困難性、弱衝突耐性）。
同じハッシュ値となる、異なる2つのメッセージのペアを求めることが（事実上）不可能であること（強衝突耐性）。
メッセージをほんの少し変えたとき、ハッシュ値は大幅に変わり、元のメッセージのハッシュ値とは相関がないように見えること。
一般に通常のハッシュ関数と比べ、長い（最低でも100ビット程度）ハッシュ値が必要であり必要な計算も多いが、メッセージのチェックなどの目的に使われることから高速に計算できるほうが望ましい。一方、ログインパスワードなどの用途では、ハッシュ値を求める計算が重い（遅い）ことが必要である。この場合には、ハッシュ値のハッシュ値を何度も求める「ストレッチング」などの技法を用いるか、この目的に適するように設計された特別な暗号学的ハッシュ関数を用いる。

ここで「（事実上）」とあるのは、探索すべき空間が有限である以上、数学的には有限の時間で探索できるので、実際には探索の計算に必要な時間が現実的に十分に長いかどうか、という意味だからである。暗号学的ハッシュ関数は情報セキュリティ分野で様々に利用されている。たとえば、デジタル署名、メッセージ認証符号 (MAC)、その他の認証技術などである。目的によって特性はそれぞれ異なる。

通常のハッシュ関数として、ハッシュテーブルのインデックス、フィンガープリント、重複データの検出、ファイルの一意な識別、データの誤りを検出するチェックサムなどにも利用できるが、通常のハッシュ関数と比べて計算が重い点で、必ずしも適していない。

暗号学的ハッシュ関数は、通常は任意長のオクテット列を入力とし、固定長のハッシュ値を出力とする。

暗号学的ハッシュ関数には、少なくとも次のような特性が必須である。
ハッシュ値 h が与えられたとき、そこから h = hash(m) となるような任意のメッセージ m を探すことが困難でなければならない。これは一方向性関数の原像計算困難性に関連している。この特性がない関数は（第1）原像攻撃に対して脆弱である。
入力 m1 が与えられたとき、hash(m1) = hash(m2) となる（すなわち、衝突する）ような別の入力 m2（m1とは異なる入力）を見つけることが困難でなければならない。これを「弱衝突耐性」ともいう。この特性がない関数は、第2原像攻撃に対して脆弱である。
hash(m1) = hash(m2) となるような2つの異なるメッセージ m1 と m2 を探し出すことが困難でなければならない。一般に誕生日のパラドックスによって、強衝突耐性を持つためには、原像計算困難性を持つために必要なハッシュ値の2倍の長さのハッシュ値が必要である。
これらの特性は、悪意ある攻撃者でもダイジェストを変化させずに入力データを改竄できないことを示すものである。したがって、2つの文字列のダイジェストが同じ場合、それらが同一のメッセージである可能性は非常に高い。

これらの基準に適合した関数でも、好ましくない特性をもつものがありうる。現在よく使われている暗号学的ハッシュ関数は伸長攻撃に対して脆弱である。すなわち、ハッシュ値 h(m) とメッセージ長 len(m) が分かっていて m そのものは不明の場合、適当な m' を選んで h (m || m') が計算できる。ここで、|| はメッセージの連結を意味する。この特性を利用して、ハッシュ関数に基づく単純な認証方式を破ることが可能である。HMACはこの問題への対策として考案された。

理想的には、さらに強い条件を課すこともできる。例えば、悪意ある者が非常によく似たダイジェストを生成する2つのメッセージを見つけることができないのが望ましい。また、ダイジェストだけから元のデータについて何らかの有用な情報を推測できないのが望ましい。これはある意味で、暗号学的ハッシュ関数は疑似乱数列を生成する関数（特に、暗号論的擬似乱数生成器）の関数に似ているといえる。しかし、決定性と計算効率は維持しなければならず、疑似乱数列生成系においては通常必要とされる最長周期の保証といった特性は、暗号学的ハッシュ関数にはない。

単純なチェックサムはもとより、巡回冗長検査などの誤り検出符号も、上で説明したような攻撃への耐性はなく、暗号的な目的には不適である。例えば、CRCがWEPでのデータ完全性保証に使われていたので、チェックサムの線形性を利用した攻撃が可能となった。

暗号学的ハッシュ関数は、任意長のメッセージを固定長の出力に変換しなければならない。したがって、入力を一連の固定長のブロックに分割し、それらに順次一方向性圧縮関数を作用させる。この圧縮関数はハッシュのために特に設計したものでもよいし、ブロック暗号を使って構築したものでもよい。Merkle-Damgård construction で構築されたハッシュ関数は、その圧縮関数と同程度の衝突困難性がある。ハッシュ関数全体で発生する衝突は、圧縮関数での衝突に起因する。最後のブロックには明らかにパディングが必要で、この部分はセキュリティ上重要である。

このような構築法を Merkle-Damgård construction と呼ぶ。SHA-1やMD5などのよく使われているハッシュ関数は、この形式である。

この構築法の本質的欠点として、length-extension 攻撃や generate-and-paste 攻撃に弱く、並列処理できないという点が挙げられる。より新しいハッシュ関数であるSHA-3は全く異なる構築法を採用している。

ブロック暗号を使って暗号学的ハッシュ関数、特に一方向性圧縮関数を構築する手法はいくつかある。

その手法は、暗号化に通常使われるブロック暗号の暗号利用モードに似ている。よく知られているハッシュ関数（MD4、MD5、SHA-1、SHA-2など）はブロック暗号的なコンポーネントを使った設計になっていて、関数が全単射にならないようフィードバックをかけている。

AESのような標準的ブロック暗号を暗号学的ハッシュ関数のブロック暗号部分に利用することも可能だが、一般に性能低下が問題となる。しかし、ハッシュと同時にブロック暗号を使った暗号化のような暗号機能も必要とするシステムで、しかもICカードのような組み込みシステムでは、コードの大きさやハードウェアの規模が制限されているので、共通化が有利となるかもしれない。

複数のハッシュ関数の出力を連結すると、連結対象のハッシュ関数のうち最強のものと少なくとも同等以上の衝突困難性を提供できる。例えば、TLS/SSLはMD5とSHA-1を連結して利用している。これによって、どちらか一方が破られても全体としてはセキュリティが保てるようにしている。

しかし、Merkle-Damgård で構成したハッシュ関数は連結しても個々のハッシュ関数と同等な強度にしかならず、より強くなることはない。Jouxによれば、MD5のハッシュ値が同じになる2つのメッセージを見つけることができれば、攻撃者がさらに同じハッシュ値となるメッセージを見つけることは簡単である。MD5で衝突を起こす多数のメッセージの中にはSHA-1でも衝突を起こすものもありうるだろう。そうなれば、SHA-1での衝突を探すのに必要な時間は多項式時間でしかない。この論旨はハル・フィニーが要約している。

暗号学的ハッシュ関数は多数存在するが、その多くは脆弱性が判明し、使われなくなっている。ハッシュ関数自体が破られたことがなくとも、それを弱めたバリエーションへの攻撃が成功すると専門家が徐々にそのハッシュ関数への信頼を失い、結果として使われなくなることもある。実際、2004年8月、当時よく使われていたハッシュ関数（SHA-0、RIPEMD、MD5など）の弱点が判明した。このことから、これらのハッシュ関数から派生したアルゴリズム、特にSHA-1（SHA-0を強化したもの）とRIPEMD-128とRIPEMD-160（RIPEMDを強化したもの）の長期的なセキュリティに疑問が投げかけられた。SHA-0とRIPEMDは、既に強化されたバージョンに置換され、使われなくなっている。

2009年現在、最も広く使われている暗号学的ハッシュ関数はMD5とSHA-1である。しかし、MD5は既に破られており、2008年にはSSLへの攻撃にその脆弱性が利用された。

SHA-0とSHA-1はNSAの開発したSHAファミリに属する。2005年2月、SHA-1について160ビットのハッシュ関数に期待される 280 回の操作より少ない 269 回のハッシュ生成で衝突を見つける攻撃法が報告された。2005年8月には 263 回で衝突を見つける攻撃法の報告があった。SHA-1には理論上の弱点も指摘されており、数年で解読されるという示唆もある。さらに2009年6月に、理論的には 252 回でSHA-1での衝突を見つけられる攻撃法が報告された。最近ではSHA-2などのより新しいSHAファミリに移行したり、衝突困難性を必要としない無作為化ハッシュなどの技法を使って問題を回避している。

しかし、ハッシュ関数を応用しているものは多く、長期的な頑健性の保証は重要である。そのためSHA-2の後継となるSHA-3の公募が行われ、2015年にFIPS規格として発行された。

メッセージ認証コードは、メッセージを認証するための短い情報である。MACアルゴリズムは、入力として共通鍵と認証すべき任意長のメッセージを受け取り、MAC（「タグ」とも呼ばれる）を出力する。MAC値は、（共通鍵をもつ）検証者がメッセージの内容の変化を検出できるようにして、メッセージの完全性を保護し、認証する。このため、メッセージ認証完全性コード（Message Authentication and Integrity Code、MAIC）とも呼ばれる。

MAC関数は暗号学的ハッシュ関数に似ているが、いくつかの必要条件の違いがある。MAC関数は選択平文攻撃における存在的偽造に対して耐性がなければならない。つまり、共通鍵を持ちMAC関数を計算できる神託機械にアクセスできる攻撃者が、任意に選んだメッセージに対応するMACを取得できたとしても、他の（神託機械に問い合わせていない）メッセージに対するMACを神託機械に対して問い合わせずに計算で求めることが計算量的に困難でなければならない。

MACはデジタル署名とは異なり、MAC値の生成と検証には同じ鍵が使われるので（共通鍵暗号）、送信者と受信者は通信を行う前に鍵を共有しておく必要がある。また、共通鍵暗号であるために、MACによって認証されるメッセージは、偽造ではなく送信者が作成し送信したという確証、つまり否認不可性をもたない。なぜなら、MAC値を検証する利用者（メッセージの受信側）は、通信の相手から受け取ったメッセージではなく、受信側で捏造したメッセージについても共通鍵を使ってMAC値を生成することができるからである。

公開鍵暗号を用いたデジタル署名では、メッセージの検証を公開鍵だけで行うことができるので、鍵の所有者はデジタル署名を作成できる秘密鍵を秘匿できる。したがって、デジタル署名が付与された文書はその所有者が署名したものと確定でき、否認不可な文書を作成することができる。

メッセージ完全性コードは、鍵を使わない点がMACとは異なる。MICとMACは同義に使われることがあるが、MICをメッセージ完全性の信頼できる標準として使うには、転送時に暗号化しなければならない。一方MACは共通鍵を使うので、暗号化しなくとも同程度の保証が可能である。あるメッセージにあるアルゴリズムを適用した場合、常に同じMICが生成される。一方、MACの場合はさらに共通鍵も同じでないと、同じMACにはならない。
